
-- 부서별 최고 급여를 받는 사원의 아이디, 이름, 급여, 부서아이디를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE (DEPARTMENT_ID, SALARY) IN (SELECT DEPARTMENT_ID ,MAX(SALARY)
                                  FROM EMPLOYEES
                                  WHERE DEPARTMENT_ID IS NOT NULL
                                  GROUP BY DEPARTMENT_ID)
ORDER BY EMPLOYEE_ID;
-- 스칼라 서브쿼리 사용하기
-- 전체 평균보다 적은 급여를 받는 사원의 아이디, 이름, 급여, 평균급여와의 차이를
-- 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY,
       TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES)-SALARY)
FROM EMPLOYEES
WHERE SALARY < (SELECT AVG(SALARY)
                FROM EMPLOYEES);        
-- 20000달러 이상은 전체 평균급여의 10%를 보너스로, 10000달러 이상은 15%, 그 외는 20%
-- 보너스로 지급하려고 한다. 아이디, 이름, 급여, 보너스 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY,
    CASE   
        WHEN SALARY >= 20000 THEN TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES)*0.1)
        WHEN SALARY >= 10000 THEN TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES)*0.15)
        ELSE TRUNC((SELECT AVG(SALARY) FROM EMPLOYEES)*0.2)
    END BONUS
FROM EMPLOYEES;
-- 전체 평균급여보다 급여를 많이 받는 사원의 이름, 급여를 조회하기
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY)
                FROM EMPLOYEES);
-- 자신이 소속된 소속부서의 평균급여보다 많은 급여를 받는 사원의 이름, 급여를 조회하기
SELECT OUTTER.FIRST_NAME, OUTTER.SALARY
FROM EMPLOYEES OUTTER
WHERE OUTTER.SALARY > (SELECT AVG(INNER.SALARY)
                       FROM EMPLOYEES INNER
                       WHERE INNER.DEPARTMENT_ID = OUTTER.DEPARTMENT_ID);
-- 외부 SQL이 실행되어서 행을 가져온다.(후보행)
-- 후보행의 행마다 DEPARTMENT_ID값을 가져와서 서브쿼리를 실행한다.
-- 서브쿼리의 결과값을 사용해서 후보행을 검증한다.
-- 후보행이 남지 않을 때까지 반복한다.
SELECT TO_DATE('20200101', 'YYYYMMDD') + LEVEL - 1
FROM DUAL
CONNECT BY LEVEL <= 31;
-- 부서아이디, 부서명, 해당부서의 사원수를 조회하기
SELECT OUTTER.DEPARTMENT_ID, OUTTER.DEPARTMENT_NAME,
       (SELECT COUNT(*)
        FROM EMPLOYEES INNER
        WHERE INNER.DEPARTMENT_ID = OUTTER.DEPARTMENT_ID) CNT
FROM DEPARTMENTS OUTTER;
-- EXISTS 연산자 사용하기
-- 부하직원을 가지고 있는 직원을 조회하기
SELECT *
FROM EMPLOYEES 상사
WHERE (SELECT COUNT(*)
       FROM EMPLOYEES 부하
       WHERE 부하.MANAGER_ID = 상사.EMPLOYEE_ID) > 0; -- COUNT() 사용 비추천
SELECT *
FROM EMPLOYEES 상사
WHERE EXISTS (SELECT 1
              FROM EMPLOYEES 부하
              WHERE 부하.MANAGER_ID = 상사.EMPLOYEE_ID); -- EXISTS 사용 추천
-- WITH 절
WITH 
DEPT_COSTS AS -- 부서이름, 부서총급여
(SELECT B.DEPARTMENT_NAME, SUM(A.SALARY) AS DEPT_TOTAL
 FROM EMPLOYEES A, DEPARTMENTS B
 WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
 GROUP BY B.DEPARTMENT_NAME),
AVG_COST AS -- 부서별 총 급여에 대한 평균급여
(SELECT SUM(DEPT_TOTAL)/COUNT(*) AS DEPT_AVG
 FROM DEPT_COSTS)
 SELECT *
 FROM DEPT_COSTS
 WHERE DEPT_TOTAL > (SELECT DEPT_AVG  
                     FROM AVG_COST)
ORDER BY DEPARTMENT_NAME;
-- 118번 사원의 상사를 조회하기
SELECT EMPLOYEE_ID, FIRST_NAME, MANAGER_ID
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 118
CONNECT BY PRIOR MANAGER_ID = EMPLOYEE_ID;
-- 101번 직원의 모든 부하 조회하기
SELECT LEVEL,EMPLOYEE_ID, FIRST_NAME, MANAGER_ID
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 101
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
-- 100(사장)의 모든 부하직원 조회
SELECT LPAD(FIRST_NAME, LENGTH(FIRST_NAME) + LEVEL*5-5, ' ')
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 100
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
-- 100의 모든 부하직원 조회, Neena는 제외(Neena의 부하도 제외)
SELECT LPAD(FIRST_NAME, LENGTH(FIRST_NAME) + LEVEL*5-5, ' ')
FROM EMPLOYEES
START WITH EMPLOYEE_ID = 100
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID AND FIRST_NAME != 'Neena';
-- 100의 모든 부하직원 조회, Neena는 제외(Neena만 제외)
SELECT LPAD(FIRST_NAME, LENGTH(FIRST_NAME) + LEVEL*5-5, ' ')
FROM EMPLOYEES
WHERE FIRST_NAME != 'Neena'
START WITH EMPLOYEE_ID = 100
CONNECT BY PRIOR EMPLOYEE_ID = MANAGER_ID;
